namespace _4._28
{
    internal class Program
    {
        static void Main(string[] args)
        {
           
        }
    }
}

//1. 선형정렬 3종 구현원리 조사
//2. 분할정복정렬 3종 구현 원리 조사
//3. 분할정복정렬 3종의 원리에 의한 특징조사(힙정렬 특징, 병합정렬 특징, 퀵정렬 특징)
//----------------------------------------------------------------------------------
//0. 시간남으면 정렬 구현 시도.
// 힙정렬이 퀵정렬보다 느릴경우는 오버헤드가 발생하여 느린거

/*   1. 선형정렬은 선택정렬, 삽입정렬,버블정렬, 계수 정렬이 있다.
 *   먼저 선택정렬은 주어진 배열을 한번 훓으면서 배열내에서 가장작은값을 선택하여 배열의 첫번째위치부터 비교해서
 *   만약에 배열 첫번째 위치와 비교했을떄 작을경우 가장작은값을 배열의 맨앞에 배치한다.
 *   그다음 배열 첫번째 위치를 제외한 배열을 뤃으면서 가장작은값을 찾고 위의 방법을 반복해서 정렬을 하는 방식이다.
 *   선택정렬은 일단n번 훓어서 가장작은값을찾고 다시 가장작은값을 찾기위해 다시 n번을 훓기때문에 시간복잡도는 O(n^2)이다.
 *   
 *   삽입정렬은 배열의 2번째 값을 특정 변수에 저장한후 변수를 배열의 첫번째부터 비교를 하여 배열의 값보다 작으면 앞쪽에 값을삽입
 *   크면 두번째 배열비교하여 작으면 삽입하는 정렬방식이다. 버블정렬과 비슷하지만 값을 다른변수에 저장한후 비교하고 삽입하는
 *   방식때문에 비슷하지만서도 다른정렬방식이다.
 *   
 *   버블정렬은 주어진배열에서 가장인접한 배열끼리 비교하여 작은값은 왼쪽에 큰값은 오른쪽으로 이동시켜서 정렬하는 방식이다.
 *    가장큰값을 오른쪽으로 밀어서 선형정렬과는 다르게 맨뒤에값인 가장큰값부터 정렬된다고 생각하면된다.
 *    일단 배열을 다 훓고 비교하는작업을n번 진행하기 때문에 시간복잡도는 선형정렬과 같다.
 *   
 *  
 *   
 *   
 *  
 *  
 * 
 * 
 * 2. 분할정렬은 힙정렬,병합정렬,퀵정렬이있다.
 * 
 *  힙정렬:배열을 힙상태 우선순위가 높은거를 맨위에두고 왼쪽에는 우선순위 작은거 오른쪽에는 우선순위가 그다음에 작은걸로배치하여
 *  우선순위가 1      의 형태로 배치되어있을때 가장 우선순위가 높은 1부터 가져와서 배열에 배치한다.
 *          2   3       그리고 기존에있던배열은 힙상태를 유지하기 위해 가장마지막에 있는 7을 맨위로 올려서
 *        4 5  6 7      
 *        
 *            7         힙상태를 유지하기 위해 7이 다시 내려간다.
 *          2   3
 *        4 5  6  
 *        
 *            2
 *          4   3
 *        7  5 6                이걸반복하여 새로운배열에 정렬을 한다.
 *  
 * 
 * 
 * 병합정렬: 주어진 배열을 반으로 나누어 숫자가 1~2개가 될때까지 나눈다음에 숫자를 비교하면서 정렬한다음에 마지막에 반으로 나눈 
 * 배열끼리 붙이는 정렬이다.(배열에 2자리 숫자를 입력했으면 그건 나누지 않는다 ex) 11 12 13등등)
 * 에를 들어        83159726 이렇게 있으면
 *                8315  9726 으로 나눈다음에 다시 배열을 나누어
 *              83  15   97  26  으로 만들어   다시 나누어
 *             8 3 1  5 9 7 2  6  된후 비교하여 작은숫자가 앞에 오게끔 다시 병합한다.
 *             38  15    79   26  그다음에 다시 숫자를 하나씩 비교하여 작은숫자가 앞에오게끔 비교한다.
 *             1358        2679   다시 같은작업을 반복한다.
 *                   12356789
 *               
 *               
 *   퀵정렬 : 주어진 배열의 첫번째 인덱스의 값을 기준으로 작은값을 임시의 1번배열에 넣고 큰값을 2번배열에 넣는다.
 *   1번배열에서 다시 첫번쨰 인덱스의 값을 기준으로 작은값을 임시의 1-1번배열에 넣고 큰값을 1-2번배열에 넣는다.
 *   위의 과정을 반복하여 인덱스가 0이나 1값을 가질때까지 반복후 병합한다.
 *              
 *         
 *         
 * 3. 힙정렬: 장점으로는 우선순위가 높은배열부터 가져와서 정렬하기 때문에 시간복잡도가 선형정렬보다 빠르다.O(nlogn)
 *            하지만 단점으로는 우선순위랑 값이 다른경우 내가 예상했던 정렬과는 다른 정렬이 될수도있다.불안정한 정렬을 할 가능성이 있다.
 * 
 *   병합정렬: 장점으로는 절반씩나누어서 하기때문에 logn이지만 최종적으로 
 *            가장작은값인 한자리수는 일일이 확인해야하므로 n을 곱한다.
 *            따라서 시간복잡도는 nlogn이 된다.
 *            단점으로는 배열의 반을 나누어 서로다른배열을 만들어서 사용하기 때문에
 *            메모리측면에서 부담이 된다.
 *     퀵정렬: 장점으로는 편균적인 시간복잡도는 병합병렬과 같은데 추가적인
 *             메모리할당이 필요없으므로 메모리적인 부담이적다.
 *             하지만 단점으로는 최악의경우 시간복잡도가 O(n^2)로 증가하고
 *             만약 병렬할려는 데이터가 추가적인 가공이 있었을경우 이미
 *             가공과정에서 어느정도 정렬이 되어있을가능성이 있기때문에
 *             퀵정렬 과정을 거치면 내가 생각했던과 다른 정렬이 될가능성이
 *             있다.즉 불안정한 정렬을 할 가능성이 있다.
 */